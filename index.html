<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>재활용 분리배출 게임</title>
  <style>
    body {
      margin: 0;
      font-family: sans-serif;
      background: #f0f0f0;
      text-align: center;
    }
    #info {
      font-size: 1.2rem;
      margin: 10px;
    }
    canvas {
      background: #ffffff;
      display: block;
      margin: 0 auto;
      max-width: 100%;
      height: auto;
      touch-action: none;
    }
  </style>
</head>
<body>
  <div id="info">
    <span id="score">점수: 0</span> |
    <span id="timer">남은 시간: 60초</span>
  </div>
  <canvas id="gameCanvas" width="800" height="600"></canvas>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    const wasteTypes = ["플라스틱", "종이", "비닐", "유리", "일반"];
    const images = {};

    let score = 0;
    let timeLeft = 60;
    let dragging = false;
    let currentTrash = null;
    let offsetX = 0, offsetY = 0;

    const bins = wasteTypes.map((type, i) => ({
      type,
      x: 50 + i * 140,
      y: 500,
      width: 100,
      height: 80
    }));

    function loadImages(callback) {
      let loaded = 0;
      const total = wasteTypes.length + 1;

      wasteTypes.forEach(type => {
        const img = new Image();
        img.src = `${type}.png`;
        img.onload = () => {
          images[type] = img;
          if (++loaded === total) callback();
        };
      });

      const binImg = new Image();
      binImg.src = "bin.png";
      binImg.onload = () => {
        images["bin"] = binImg;
        if (++loaded === total) callback();
      };
    }

    function newTrash() {
      const type = wasteTypes[Math.floor(Math.random() * wasteTypes.length)];
      return {
        type,
        x: Math.random() * 600 + 100,
        y: 50,
        width: 100,
        height: 50
      };
    }

    function drawGame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      bins.forEach(bin => {
        ctx.drawImage(images["bin"], bin.x, bin.y, bin.width, bin.height);
        ctx.fillStyle = "black";
        ctx.fillText(bin.type, bin.x + 10, bin.y - 10);
      });

      if (currentTrash) {
        ctx.drawImage(images[currentTrash.type], currentTrash.x, currentTrash.y, currentTrash.width, currentTrash.height);
        ctx.fillStyle = "black";
        ctx.fillText(currentTrash.type, currentTrash.x + 5, currentTrash.y + 60);
      }

      document.getElementById("score").textContent = `점수: ${score}`;
      document.getElementById("timer").textContent = `남은 시간: ${timeLeft}초`;
    }

    // ✅ 마우스 이벤트
    canvas.addEventListener("mousedown", e => {
      handleStart(e.offsetX, e.offsetY);
    });

    canvas.addEventListener("mouseup", e => {
      handleEnd(e.offsetX, e.offsetY);
    });

    canvas.addEventListener("mousemove", e => {
      handleMove(e.offsetX, e.offsetY);
    });

    // ✅ 터치 이벤트
    canvas.addEventListener("touchstart", e => {
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      handleStart(x, y);
    });

    canvas.addEventListener("touchend", e => {
      handleEnd();
    });

    canvas.addEventListener("touchmove", e => {
      e.preventDefault(); // 스크롤 방지
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      const x = touch.clientX - rect.left;
      const y = touch.clientY - rect.top;
      handleMove(x, y);
    });

    // ✅ 드래그 처리 함수 분리
    function handleStart(x, y) {
      if (
        currentTrash &&
        x >= currentTrash.x &&
        x <= currentTrash.x + currentTrash.width &&
        y >= currentTrash.y &&
        y <= currentTrash.y + currentTrash.height
      ) {
        dragging = true;
        offsetX = currentTrash.x - x;
        offsetY = currentTrash.y - y;
      }
    }

    function handleMove(x, y) {
      if (dragging) {
        currentTrash.x = x + offsetX;
        currentTrash.y = y + offsetY;
      }
    }

    function handleEnd() {
      if (dragging) {
        dragging = false;
        const cx = currentTrash.x + currentTrash.width / 2;
        const cy = currentTrash.y + currentTrash.height / 2;
        let matched = false;
        bins.forEach(bin => {
          if (
            cx > bin.x &&
            cx < bin.x + bin.width &&
            cy > bin.y &&
            cy < bin.y + bin.height
          ) {
            if (bin.type === currentTrash.type) {
              score++;
            } else {
              score--;
            }
            matched = true;
          }
        });
        if (matched) {
          currentTrash = newTrash();
        }
      }
    }

    function gameLoop() {
      drawGame();
    }

    function startGame() {
      currentTrash = newTrash();
      setInterval(() => {
        if (timeLeft > 0) {
          timeLeft--;
        }
      }, 1000);

      setInterval(gameLoop, 1000 / 60);

      setTimeout(() => {
        alert(`게임 종료! 최종 점수는 ${score}점입니다.`);
      }, 60000);
    }

    loadImages(startGame);
  </script>
</body>
</html>
